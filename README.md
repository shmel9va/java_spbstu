# Система управления задачами - Step 1

## Описание
Это простое REST API для управления задачами и уведомлениями пользователей.
Реализованы основные функции создания задач, управления пользователями и уведомлениями.
Данные хранятся в памяти (без использования базы данных).

## Технологии
- Java 17
- Spring Boot
- Gradle

## API Endpoints

### Задачи
- GET /api/tasks/{userId} - получить все задачи пользователя
- GET /api/tasks/{userId}/pending - получить только активные (незавершенные) задачи
- POST /api/tasks - создать новую задачу
- DELETE /api/tasks/{id} - пометить задачу как удаленную

### Пользователи
- GET /api/users/login - авторизация пользователя
- POST /api/users/register - регистрация нового пользователя

### Уведомления
- GET /api/notifications/{userId} - получить все уведомления пользователя
- GET /api/notifications/{userId}/pending - получить непрочитанные уведомления
- POST /api/notifications/{id}/read - пометить уведомление как прочитанное

# Написание unit-тестов - Step 2

## Описание

В рамках шага 2 были реализованы юнит-тесты для всех основных компонентов приложения:


## 1. Подготовка проекта

- Добавлены зависимости в `build.gradle`:
  - **JUnit Jupiter** — для написания тестов
  - **Mockito** — для создания моков
  - **Spring Boot Test** — для интеграции с Spring

## 2. Тесты сервисного слоя

### `UserServiceTest`
- Получение пользователя по имени
- Создание нового пользователя
- Аутентификация (успешная и неуспешная)

### `TaskServiceTest`
- Получение всех задач пользователя
- Получение невыполненных задач
- Создание задачи
- Удаление задачи

### `NotificationServiceTest`
- Получение всех уведомлений
- Получение непрочитанных уведомлений
- Пометка как прочитанное
- Создание уведомления


## 3. Тесты контроллеров

### `UserControllerTest`
- Успешный и неуспешный логин
- Регистрация пользователя

### `TaskControllerTest`
- Получение всех задач
- Получение невыполненных задач
- Создание задачи
- Удаление задачи

### `NotificationControllerTest`
- Получение всех уведомлений
- Получение непрочитанных уведомлений
- Отметка уведомления как прочитанного


## Результат

Все тесты успешно проходят.  
Покрытие охватывает ключевую бизнес-логику сервисов и REST API интерфейсы.
---
# Интеграция с In-Memory базой данных (H2) - Step 3

## Описание

В рамках шага 3 проект был модифицирован для работы с базами данных. Для этого была добавлена поддержка H2 - легковесной in-memory базы данных, и реализована инфраструктура Spring Data JPA.

## Основные изменения:

1. **Добавлена поддержка Spring Data JPA:**
  - Добавлены зависимости для работы с H2 и JPA в `build.gradle`
  - Сущности (`Task`, `User`, `Notification`) теперь аннотированы с `@Entity`
  - Созданы JPA-репозитории для всех сущностей

2. **Реализованы профили для переключения между хранилищами:**
  - `dev` - использует хранилище в памяти (Map) для быстрой разработки
  - `database` - использует H2 базу данных через JPA репозитории

3. **Адаптеры для поддержания совместимости:**
  - `JpaTaskRepositoryAdapter`, `JpaUserRepositoryAdapter`, `JpaNotificationRepositoryAdapter` - связывают интерфейсы базовых репозиториев с JPA имплементациями

---
# Добавление поддержки Docker - Step 4

## Описание

В рамках шага 4 была добавлена поддержка Docker для запуска приложения в контейнере с использованием H2 базы данных.

## Основные изменения:

1. **Создан оптимизированный Dockerfile:**

2. **Настроен Docker Compose:**

3. **Добавлены настройки H2 для работы в Docker:**

## Как запустить приложение в Docker

1. Соберите и запустите Docker контейнер:
   ```bash
   docker-compose up -d --build
   ```

2. Проверьте статус контейнера:
   ```bash
   docker-compose ps
   ```

3. Просмотр логов приложения:
   ```bash
   docker-compose logs -f app
   ```

4. Остановка контейнера:
   ```bash
   docker-compose down
   ```

---
# Переход на MySQL - Step 5

## Описание

В рамках шага 5 проект был модифицирован для работы с MySQL вместо H2, при этом сохранена возможность использования обеих баз данных через профили Spring.

## Основные изменения:

1. **Добавлена поддержка MySQL:**
   - Добавлены зависимости для работы с MySQL
   - Создан профиль `mysql` для конфигурации MySQL
   - Репозитории настроены для работы с обеими базами данных

2. **Внедрена система миграций Flyway:**
   - Добавлены зависимости Flyway
   - Созданы миграционные скрипты для инициализации схемы базы данных
   - Настроена автоматическая миграция при запуске приложения

3. **Обновлен Docker Compose:**
   - Добавлен сервис MySQL
   - Настроено взаимодействие между сервисами
   - Сохранены данные в именованных томах

## Как переключаться между профилями

Приложение поддерживает следующие профили:
- `dev` - использует хранилище в памяти (Map) для быстрой разработки
- `database` - использует H2 базу данных через JPA репозитории
- `mysql` - использует MySQL базу данных через JPA репозитории с миграциями Flyway

Для запуска с нужным профилем используйте параметр:
```bash
java -jar app.jar --spring.profiles.active=mysql
```

---
# Реализация системы сообщений с Kafka - Step 7

## Описание

В рамках шага 7 была реализована асинхронная система сообщений с использованием Apache Kafka для обработки событий создания и удаления задач.

## Основные изменения:

### 1. **Интеграция Kafka:**
   - Добавлены зависимости Spring Kafka в `build.gradle`
   - Настроена конфигурация Kafka producer и consumer
   - Добавлены Kafka и Zookeeper в `docker-compose.yml`

### 2. **Модель событий:**
   - Создана модель `TaskEvent` для передачи данных о событиях задач
   - Поддерживаются типы событий: `CREATED`, `DELETED`, `UPDATED`

### 3. **Kafka Producer:**
   - Создан сервис `TaskEventProducer` для отправки событий в Kafka
   - События отправляются в топик `task-events`

### 4. **Kafka Consumer:**
   - Создан `TaskEventListener` для асинхронной обработки событий
   - Listener автоматически создает уведомления при получении событий

### 5. **Рефакторинг NotificationService:**
   - Убран публичный метод `createNotification` из API
   - Уведомления теперь создаются ТОЛЬКО через Kafka listener
   - Сохранены методы для получения и управления уведомлениями

### 6. **Обновление TaskService:**
   - Заменены прямые вызовы NotificationService на отправку событий в Kafka
   - При создании/удалении задач отправляются соответствующие события

## Архитектура системы сообщений

```
TaskService -> TaskEventProducer -> Kafka Topic -> TaskEventListener -> NotificationService
```

1. **TaskService** создает/удаляет задачу и отправляет событие через **TaskEventProducer**
2. **TaskEventProducer** публикует событие в Kafka топик `task-events`
3. **TaskEventListener** асинхронно получает событие из Kafka
4. **TaskEventListener** создает уведомление через внутренний метод **NotificationService**

## Конфигурация

### Kafka настройки в `application.properties`:
```properties
# Kafka Configuration
spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.consumer.group-id=task-notification-group
spring.kafka.consumer.auto-offset-reset=earliest

# Application Kafka Topics
app.kafka.task-events-topic=task-events
```

## Как запустить с Kafka

1. **Запуск всех сервисов через Docker Compose:**
   ```bash
   docker-compose up -d
   ```

2. **Проверка статуса сервисов:**
   ```bash
   docker-compose ps
   ```

3. **Просмотр логов Kafka:**
   ```bash
   docker-compose logs -f kafka
   ```

4. **Просмотр логов приложения:**
   ```bash
   docker-compose logs -f app
   ```

## Преимущества новой архитектуры

- **Асинхронность:** Создание уведомлений не блокирует основные операции
- **Масштабируемость:** Можно добавить несколько consumer'ов для обработки событий
- **Надежность:** Kafka гарантирует доставку сообщений
- **Разделение ответственности:** TaskService фокусируется на задачах, NotificationService - на уведомлениях
- **Расширяемость:** Легко добавить новые типы событий и обработчиков

## Тестирование

Для тестирования Kafka функциональности без запущенного Kafka сервера используйте профиль `dev`:
```bash
./gradlew test --tests "com.example.lab.kafka.KafkaIntegrationTest" -Dspring.profiles.active=dev
```